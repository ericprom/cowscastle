{"version":3,"sources":["meteor://ðŸ’»app/packages/splendido_accounts-meld/packages/splendido_accounts-meld.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mG","file":"/packages/splendido_accounts-meld.js","sourcesContent":["(function () {\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/splendido:accounts-meld/lib/_globals.js                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n                                                                                      // 1\nAccountsMeld = undefined;                                                             // 2\n                                                                                      // 3\ncheckForMelds = undefined;                                                            // 4\n                                                                                      // 5\nMeldActions = undefined;                                                              // 6\n                                                                                      // 7\nupdateOrCreateUserFromExternalService = undefined;                                    // 8\n                                                                                      // 9\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/splendido:accounts-meld/lib/accounts-meld-server.js                       //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n/* global                                                                             // 1\n\t\tAccountsEmailsField: false,                                                         // 2\n    AccountsMeld: true,                                                               // 3\n    checkForMelds: true,                                                              // 4\n\t\tMeldActions: true,                                                                  // 5\n    updateOrCreateUserFromExternalService: true                                       // 6\n*/                                                                                    // 7\n'use strict';                                                                         // 8\n                                                                                      // 9\n// ----------------------------------------                                           // 10\n// Collection to keep meld action documents                                           // 11\n// ----------------------------------------                                           // 12\n                                                                                      // 13\n// Each document is composed as follow:                                               // 14\n// {                                                                                  // 15\n//     dst_user_id: user_id associated to the account which should survive            // 16\n//     src_user_id: user_id associated to the account to be deleted                   // 17\n//     meld:        one of [\"ask\", yes\", \"not_now\", \"never\", \"melding\", \"done\"]       // 18\n//                  used to track the status of the meld action.                      // 19\n//     src_info: {  a bit of information about the source account                     // 20\n//       emails: src_user.registered_emails (see accounts-emails-field package)       // 21\n//       services: array of registered services' name, but 'resume'                   // 22\n//     }                                                                              // 23\n//     dst_info: {  a bit of information about the destination account                // 24\n//       emails: dst_user.registered_emails (see accounts-emails-field package)       // 25\n//       services: array of registered services' name, but 'resume'                   // 26\n//     }                                                                              // 27\n// }                                                                                  // 28\n//                                                                                    // 29\n//                                                                                    // 30\n// Server - Client interaction flow:                                                  // 31\n//                                                                                    // 32\n// 1) a meld action is created: 'meld': 'ask'                                         // 33\n// 2) the client is prompted with a question for which answer allowed values are      // 34\n//    - 'yes' -> requires to perform the meld action                                  // 35\n//    - 'not_now' -> requires to as again at the next login                           // 36\n//    - 'never' -> requires not to meld and not to bother again...                    // 37\n//                                                                                    // 38\n// 3a) client updates the meld action an sets 'meld': 'yes'                           // 39\n// 3aa) server sets 'meld': 'melding'                                                 // 40\n//      (so that client can visualize something...)                                   // 41\n// 3ab) in case the meld action cannot be performed because of the same service       // 42\n//      appearing inside both accounts but with different ids the server sets         // 43\n//      'meld': 'ask'                                                                 // 44\n//      ...the hope is the user can remove one of the two conflitting services        // 45\n//      and then ask again to meld.                                                   // 46\n//      should be probably very rare, but SOMETHING BETTER SHOULD BE DONE!            // 47\n// 3ac) when the meld action is completed the server sets 'meld': 'done'              // 48\n// 3ad) the client should visualize something and then set 'meld': 'ok'               // 49\n//                                                                                    // 50\n// 3b) client updates the meld action an sets 'meld': 'not_now'                       // 51\n// 3ba) at the next login the server changes 'meld': 'not_now' --> 'meld': 'ask'      // 52\n//                                                                                    // 53\n// 3c) client updates the meld action an sets 'meld': 'never'                         // 54\n// 3ca) at the next login the server sees the mels action with 'meld': 'never'        // 55\n//      and does nothing...                                                           // 56\n//                                                                                    // 57\n                                                                                      // 58\nMeldActions = new Meteor.Collection(\"meldActions\");                                   // 59\n                                                                                      // 60\n// Allow client-side modification of a meld action only                               // 61\n// to catch the user answer after having proposed a meld                              // 62\n// and to delete the document of a completed meld action.                             // 63\nMeldActions.allow({                                                                   // 64\n\tupdate: function(userId, doc, fieldNames, modifier) {                                // 65\n\t\t// Only the destination user can modify a document                                  // 66\n\t\tif (userId !== doc.dst_user_id) {                                                   // 67\n\t\t\treturn false;                                                                      // 68\n\t\t}                                                                                   // 69\n\t\t// ...and only the field meld can be modified                                       // 70\n\t\tif (fieldNames.length > 1 || fieldNames[0] !== \"meld\") {                            // 71\n\t\t\treturn false;                                                                      // 72\n\t\t}                                                                                   // 73\n\t\t// ...and only if meld is 'ask' or 'melding'                                        // 74\n\t\tif (!_.contains(['ask', 'melding'], doc.meld)) {                                    // 75\n\t\t\treturn false;                                                                      // 76\n\t\t}                                                                                   // 77\n\t\t// ...when meld is \"ask\" only [\"yes\", \"not_now\", \"never\"] are allowed               // 78\n\t\tif (doc.meld === \"ask\") {                                                           // 79\n\t\t\tvar allowedModifiers = [{                                                          // 80\n\t\t\t\t'$set': {                                                                         // 81\n\t\t\t\t\tmeld: 'yes'                                                                      // 82\n\t\t\t\t}                                                                                 // 83\n\t\t\t}, {                                                                               // 84\n\t\t\t\t'$set': {                                                                         // 85\n\t\t\t\t\tmeld: 'not_now'                                                                  // 86\n\t\t\t\t}                                                                                 // 87\n\t\t\t}, {                                                                               // 88\n\t\t\t\t'$set': {                                                                         // 89\n\t\t\t\t\tmeld: 'never'                                                                    // 90\n\t\t\t\t}                                                                                 // 91\n\t\t\t}];                                                                                // 92\n\t\t\tvar notAllowed = _.every(allowedModifiers, function(mod) {                         // 93\n\t\t\t\treturn !_.isEqual(mod, modifier);                                                 // 94\n\t\t\t});                                                                                // 95\n\t\t\tif (notAllowed) {                                                                  // 96\n\t\t\t\treturn false;                                                                     // 97\n\t\t\t}                                                                                  // 98\n\t\t}                                                                                   // 99\n\t\t// ...when meld is \"melding\" only answer \"ok\" is allowed                            // 100\n\t\tif (doc.meld === \"melding\") {                                                       // 101\n\t\t\tif (!_.isEqual(modifier, {                                                         // 102\n\t\t\t\t\t'$set': {                                                                        // 103\n\t\t\t\t\t\tmeld: 'ok'                                                                      // 104\n\t\t\t\t\t}                                                                                // 105\n\t\t\t\t})) {                                                                             // 106\n\t\t\t\treturn false;                                                                     // 107\n\t\t\t}                                                                                  // 108\n\t\t}                                                                                   // 109\n\t\t// ...only in case all the above conditions are satisfied:                          // 110\n\t\treturn true;                                                                        // 111\n\t},                                                                                   // 112\n\tremove: function(userId, doc) {                                                      // 113\n\t\t// no removals unless the meld action is completed!                                 // 114\n\t\treturn doc.meld === \"done\";                                                         // 115\n\t}                                                                                    // 116\n});                                                                                   // 117\n                                                                                      // 118\n// Publish meld action registered for the current user                                // 119\n// ...except those marked with \"ok\", yes\", \"not_now\", \"never\"                         // 120\n//    which are not meant to be displayed client-side.                                // 121\nMeteor.publish(\"pendingMeldActions\", function() {                                     // 122\n\treturn MeldActions.find({                                                            // 123\n\t\tdst_user_id: this.userId,                                                           // 124\n\t\tmeld: {                                                                             // 125\n\t\t\t$nin: [\"not_now\", \"never\", \"ok\", \"yes\"]                                            // 126\n\t\t}                                                                                   // 127\n\t});                                                                                  // 128\n});                                                                                   // 129\n                                                                                      // 130\n// Observe the changes of meld actions to respond to                                  // 131\n// client-side user interactions:                                                     // 132\n//  - remove unnecessary data when a meld action is marked                            // 133\n//    as to be never performed                                                        // 134\n//  - actually proceed to meld accounts when the client-side                          // 135\n//    answer is \"yes\"                                                                 // 136\nMeldActions.find().observeChanges({                                                   // 137\n\tchanged: function(id, fields) {                                                      // 138\n\t\tif (fields.meld === \"never\") {                                                      // 139\n\t\t\t// Remove unnecessary data from the document                                       // 140\n\t\t\tMeldActions.update(id, {                                                           // 141\n\t\t\t\t$unset: {                                                                         // 142\n\t\t\t\t\tsrc_info: \"\",                                                                    // 143\n\t\t\t\t\tdst_info: \"\"                                                                     // 144\n\t\t\t\t}                                                                                 // 145\n\t\t\t});                                                                                // 146\n\t\t} else if (fields.meld === \"yes\") {                                                 // 147\n\t\t\t// Proceed with actual melding of the two accounts...                              // 148\n\t\t\tAccountsMeld.executeMeldAction(id);                                                // 149\n\t\t}                                                                                   // 150\n\t}                                                                                    // 151\n});                                                                                   // 152\n                                                                                      // 153\n                                                                                      // 154\n                                                                                      // 155\n// ------------------                                                                 // 156\n// AccountsMeld class                                                                 // 157\n// ------------------                                                                 // 158\n                                                                                      // 159\nvar AM = function() {};                                                               // 160\n                                                                                      // 161\n// Configuration pattern to be checked with check                                     // 162\nAM.prototype.CONFIG_PAT = {                                                           // 163\n\taskBeforeMeld: Match.Optional(Boolean),                                              // 164\n\tcheckForConflictingServices: Match.Optional(Boolean),                                // 165\n\tmeldUserCallback: Match.Optional(Match.Where(_.isFunction)),                         // 166\n\tmeldDBCallback: Match.Optional(Match.Where(_.isFunction)),                           // 167\n\tserviceAddedCallback: Match.Optional(Match.Where(_.isFunction))                      // 168\n};                                                                                    // 169\n                                                                                      // 170\n// Current configuration values                                                       // 171\nAM.prototype._config = {                                                              // 172\n\t// Flags telling whether to ask the user before melding any two accounts             // 173\n\taskBeforeMeld: false,                                                                // 174\n\t// Flags telling whether to check for conflicting services before melding            // 175\n\tcheckForConflictingServices: false,                                                  // 176\n\t// Reference to the callback to meld user objects                                    // 177\n\tmeldUserCallback: null,                                                              // 178\n\t// Reference to the callback to meld collections' objects                            // 179\n\tmeldDBCallback: null,                                                                // 180\n\t// Reference to the callback to update user profile when a service is added          // 181\n\tserviceAddedCallback: null                                                           // 182\n};                                                                                    // 183\n                                                                                      // 184\nAM.prototype._meldUsersObject = function(srcUser, dstUser) {                          // 185\n\t// Checks whether a callback for melding users' object was specified                 // 186\n\tvar meldUserCallback = this.getConfig('meldUserCallback');                           // 187\n\t// ...in case it was, uses the requested one                                         // 188\n\tif (meldUserCallback) {                                                              // 189\n\t\tvar meldedUser = meldUserCallback(srcUser, dstUser);                                // 190\n\t\tmeldedUser = _.omit(                                                                // 191\n\t\t\tmeldedUser,                                                                        // 192\n\t\t\t'_id', 'services', 'emails', 'registered_emails'                                   // 193\n\t\t);                                                                                  // 194\n\t\t_.each(meldedUser, function(value, key) {                                           // 195\n\t\t\tdstUser[key] = value;                                                              // 196\n\t\t});                                                                                 // 197\n\t}                                                                                    // 198\n\t// ...otherwise perfors some default fusion                                          // 199\n\telse {                                                                               // 200\n\t\t// 'createdAt' field: keep the oldest between the two                               // 201\n\t\tif (srcUser.createdAt < dstUser.createdAt) {                                        // 202\n\t\t\tdstUser.createdAt = srcUser.createdAt;                                             // 203\n\t\t}                                                                                   // 204\n\t\t// 'profile' field                                                                  // 205\n\t\tvar profile = {};                                                                   // 206\n\t\t_.defaults(profile, dstUser.profile || {});                                         // 207\n\t\t_.defaults(profile, srcUser.profile || {});                                         // 208\n\t\tif (!_.isEmpty(profile)) {                                                          // 209\n\t\t\tdstUser.profile = profile;                                                         // 210\n\t\t}                                                                                   // 211\n\t}                                                                                    // 212\n\t// 'services' field (at this point we know some check was already done...)           // 213\n\t// adds services appearing inside the src user which                                 // 214\n\t// do not appear inside the destination user (but for 'resume')                      // 215\n\t// TODO: check whether we need to re-encrypt data using                              // 216\n\t//       'pinEncryptedFieldsToUser'. See                                             // 217\n\t//       meteor/packages/accounts-base/accounts_server.js#L1136                      // 218\n\tvar newServices = {};                                                                // 219\n\tvar srcServices = _.omit(srcUser.services, _.keys(dstUser.services));                // 220\n\t// NOTE: it is mandatory to skip also 'resume' data in order to prevent the          // 221\n\t//       current login action to be interrupted in case the srcUser actually         // 222\n\t//       has a different and outdated 'resume' data.                                 // 223\n\tsrcServices = _.omit(srcUser.services, \"resume\");                                    // 224\n\t_.each(_.keys(srcServices), function(serviceName) {                                  // 225\n\t\tnewServices['services.' + serviceName] = srcServices[serviceName];                  // 226\n\t\tdstUser.services[serviceName] = srcServices[serviceName];                           // 227\n\t});                                                                                  // 228\n\t// TODO: check there are no overlapping services which have different ids!!!         // 229\n\t//       'emails' field: fuses the two emails fields, giving precedence to           // 230\n\t//       verified ones...                                                            // 231\n\tvar srcEmails = srcUser.emails || [];                                                // 232\n\tvar dstEmails = dstUser.emails || [];                                                // 233\n\t// creates an object with addresses as keys and verification status as values        // 234\n\tvar emails = {};                                                                     // 235\n\t_.each(_.flatten([srcEmails, dstEmails]), function(email) {                          // 236\n\t\temails[email.address] = emails[email.address] || email.verified;                    // 237\n\t});                                                                                  // 238\n\t// transforms emails back to                                                         // 239\n\t// [{address: addr1, verified: bool}, {address: addr2, verified: bool}, ...]         // 240\n\tdstUser.emails = _.map(emails, function(verified, address) {                         // 241\n\t\treturn {                                                                            // 242\n\t\t\taddress: address,                                                                  // 243\n\t\t\tverified: verified                                                                 // 244\n\t\t};                                                                                  // 245\n\t});                                                                                  // 246\n\tif (!dstUser.emails.length) {                                                        // 247\n\t\tdelete dstUser.emails;                                                              // 248\n\t}                                                                                    // 249\n\t// updates the registered_emails field                                               // 250\n\tAccountsEmailsField.updateEmails({                                                   // 251\n\t\tuser: dstUser                                                                       // 252\n\t});                                                                                  // 253\n\t// Removes the old user                                                              // 254\n\tMeteor.users.remove(srcUser._id);                                                    // 255\n\t// Updates the current user                                                          // 256\n\tMeteor.users.update(dstUser._id, {                                                   // 257\n\t\t$set: _.omit(dstUser, \"_id\", \"services\")                                            // 258\n\t});                                                                                  // 259\n\tMeteor.users.update(dstUser._id, {                                                   // 260\n\t\t$set: newServices                                                                   // 261\n\t});                                                                                  // 262\n};                                                                                    // 263\n                                                                                      // 264\nAM.prototype.getConfig = function(paramName) {                                        // 265\n\treturn this._config[paramName];                                                      // 266\n};                                                                                    // 267\n                                                                                      // 268\nAM.prototype.configure = function(config) {                                           // 269\n\tcheck(config, this.CONFIG_PAT);                                                      // 270\n\t// Update the current configuration                                                  // 271\n\tthis._config = _.defaults(config, this._config);                                     // 272\n};                                                                                    // 273\n                                                                                      // 274\nAM.prototype.createMeldAction = function(srcUser, dstUser) {                          // 275\n\tMeldActions.insert({                                                                 // 276\n\t\tsrc_user_id: srcUser._id,                                                           // 277\n\t\tdst_user_id: dstUser._id,                                                           // 278\n\t\tmeld: \"ask\",                                                                        // 279\n\t\tsrc_info: {                                                                         // 280\n\t\t\temails: srcUser.registered_emails,                                                 // 281\n\t\t\tservices: _.without(_.keys(srcUser.services), \"resume\")                            // 282\n\t\t},                                                                                  // 283\n\t\tdst_info: {                                                                         // 284\n\t\t\temails: dstUser.registered_emails,                                                 // 285\n\t\t\tservices: _.without(_.keys(dstUser.services), \"resume\")                            // 286\n\t\t}                                                                                   // 287\n\t});                                                                                  // 288\n};                                                                                    // 289\n                                                                                      // 290\nAM.prototype.executeMeldAction = function(id) {                                       // 291\n\t// Retrieve the meld action document                                                 // 292\n\tvar meldAction = MeldActions.findOne(id);                                            // 293\n\t// Marks the meld action as \"melding\"                                                // 294\n\tMeldActions.update(meldAction._id, {                                                 // 295\n\t\t$set: {                                                                             // 296\n\t\t\tmeld: \"melding\"                                                                    // 297\n\t\t}                                                                                   // 298\n\t});                                                                                  // 299\n                                                                                      // 300\n\t// Retrieve the source account                                                       // 301\n\tvar srcUser = Meteor.users.findOne(meldAction.src_user_id);                          // 302\n\t// Retrieve the destination account                                                  // 303\n\tvar dstUser = Meteor.users.findOne(meldAction.dst_user_id);                          // 304\n                                                                                      // 305\n\t// Actually melds the two accounts                                                   // 306\n\tvar meldResult = this.meldAccounts(srcUser, dstUser);                                // 307\n\tif (meldResult) {                                                                    // 308\n\t\t// Marks the meld action as \"done\"                                                  // 309\n\t\tMeldActions.update(meldAction._id, {                                                // 310\n\t\t\t$set: {                                                                            // 311\n\t\t\t\tmeld: \"done\"                                                                      // 312\n\t\t\t}                                                                                  // 313\n\t\t});                                                                                 // 314\n\t\t// Possibly removes old meld actions registered for the same two                    // 315\n\t\t// accounts but for the opposite direction                                          // 316\n\t\tvar invMeldAction = MeldActions.findOne({                                           // 317\n\t\t\tsrc_user_id: meldAction.dst_user_id,                                               // 318\n\t\t\tdst_user_id: meldAction.src_user_id,                                               // 319\n\t\t});                                                                                 // 320\n\t\tif (invMeldAction) {                                                                // 321\n\t\t\tMeldActions.remove(invMeldAction._id);                                             // 322\n\t\t}                                                                                   // 323\n\t} else {                                                                             // 324\n\t\t// XXX TODO: For now this seems the only thing to be improved in a near             // 325\n\t\t//           future. Some error status and better client communication of           // 326\n\t\t//           the problem should be put in place...                                  // 327\n\t\tMeldActions.update(meldAction._id, {                                                // 328\n\t\t\t$set: {                                                                            // 329\n\t\t\t\tmeld: \"not_now\"                                                                   // 330\n\t\t\t}                                                                                  // 331\n\t\t});                                                                                 // 332\n\t}                                                                                    // 333\n};                                                                                    // 334\n                                                                                      // 335\nAM.prototype.meldAccounts = function(srcUser, dstUser) {                              // 336\n\t//checks there are no overlapping services which have different ids!!!               // 337\n\tvar canMeld = true;                                                                  // 338\n\t// Checks for conflicting services before proceeding with actual melding             // 339\n\tif (this.getConfig('checkForConflictingServices')) {                                 // 340\n\t\tif (!!srcUser.services && !!dstUser.services) {                                     // 341\n\t\t\t_.each(_.keys(srcUser.services), function(serviceName) {                           // 342\n\t\t\t\tif (serviceName !== \"resume\" && !!dstUser.services[serviceName]) {                // 343\n\t\t\t\t\tif (serviceName === \"password\") {                                                // 344\n\t\t\t\t\t\tvar sameService = _.isEqual(                                                    // 345\n\t\t\t\t\t\t\tsrcUser.services[serviceName],                                                 // 346\n\t\t\t\t\t\t\tdstUser.services[serviceName]                                                  // 347\n\t\t\t\t\t\t);                                                                              // 348\n\t\t\t\t\t\tif (!sameService) {                                                             // 349\n\t\t\t\t\t\t\tcanMeld = false;                                                               // 350\n\t\t\t\t\t\t}                                                                               // 351\n\t\t\t\t\t} else {                                                                         // 352\n\t\t\t\t\t\tvar srcService = srcUser.services[serviceName];                                 // 353\n\t\t\t\t\t\tvar dstService = dstUser.services[serviceName];                                 // 354\n\t\t\t\t\t\tif (!!srcService.id &&                                                          // 355\n\t\t\t\t\t\t\t!!dstService.id &&                                                             // 356\n\t\t\t\t\t\t\tsrcService.id !== dstService.id                                                // 357\n\t\t\t\t\t\t) {                                                                             // 358\n\t\t\t\t\t\t\tcanMeld = false;                                                               // 359\n\t\t\t\t\t\t}                                                                               // 360\n\t\t\t\t\t}                                                                                // 361\n\t\t\t\t}                                                                                 // 362\n\t\t\t});                                                                                // 363\n\t\t}                                                                                   // 364\n\t}                                                                                    // 365\n\tif (!canMeld) {                                                                      // 366\n\t\treturn false;                                                                       // 367\n\t}                                                                                    // 368\n\t// Melds users'object                                                                // 369\n\tthis._meldUsersObject(srcUser, dstUser);                                             // 370\n\t// Check whether a callback for DB document migration was specified                  // 371\n\tvar meldDBCallback = this.getConfig('meldDBCallback');                               // 372\n\tif (meldDBCallback) {                                                                // 373\n\t\tmeldDBCallback(srcUser._id, dstUser._id);                                           // 374\n\t}                                                                                    // 375\n\treturn true;                                                                         // 376\n};                                                                                    // 377\n                                                                                      // 378\nAccountsMeld = new AM();                                                              // 379\n                                                                                      // 380\n                                                                                      // 381\n                                                                                      // 382\n                                                                                      // 383\n// ------------------------------------------------                                   // 384\n// Callback functions to be registered with 'hooks'                                   // 385\n// ------------------------------------------------                                   // 386\n                                                                                      // 387\n                                                                                      // 388\n                                                                                      // 389\ncheckForMelds = function(dstUser) {                                                   // 390\n\t// Updates all possibly pending meld actions...                                      // 391\n\tMeldActions.update({                                                                 // 392\n\t\tdst_user_id: dstUser._id,                                                           // 393\n\t\tmeld: \"not_now\"                                                                     // 394\n\t}, {                                                                                 // 395\n\t\t$set: {                                                                             // 396\n\t\t\tmeld: \"ask\"                                                                        // 397\n\t\t}                                                                                   // 398\n\t}, {                                                                                 // 399\n\t\tmulti: true                                                                         // 400\n\t});                                                                                  // 401\n\t// Picks up verified email addresses and creates a list like                         // 402\n\t// [                                                                                 // 403\n\t//    {$elemMatch: {\"address\": addr1, \"verified\": true}},                            // 404\n\t//    {$elemMatch: {\"address\": addr2, \"verified\": true}},                            // 405\n\t//    ...                                                                            // 406\n\t// ]                                                                                 // 407\n\tvar queryEmails = _.chain(dstUser.registered_emails)                                 // 408\n\t\t.filter(function(email) {                                                           // 409\n\t\t\treturn email.verified;                                                             // 410\n\t\t})                                                                                  // 411\n\t\t.map(function(email) {                                                              // 412\n\t\t\treturn {                                                                           // 413\n\t\t\t\t\"registered_emails\": {                                                            // 414\n\t\t\t\t\t$elemMatch: email                                                                // 415\n\t\t\t\t}                                                                                 // 416\n\t\t\t};                                                                                 // 417\n\t\t})                                                                                  // 418\n\t\t.value();                                                                           // 419\n\t// In case there is at least one registered address                                  // 420\n\tif (queryEmails.length) {                                                            // 421\n\t\t// Finds users with at least one registered email address matching the              // 422\n\t\t// above list                                                                       // 423\n\t\tif (queryEmails.length > 1) {                                                       // 424\n\t\t\tqueryEmails = {                                                                    // 425\n\t\t\t\t$or: queryEmails                                                                  // 426\n\t\t\t};                                                                                 // 427\n\t\t} else {                                                                            // 428\n\t\t\tqueryEmails = queryEmails[0];                                                      // 429\n\t\t}                                                                                   // 430\n\t\t// Excludes current user...                                                         // 431\n\t\tqueryEmails._id = {                                                                 // 432\n\t\t\t$ne: dstUser._id                                                                   // 433\n\t\t};                                                                                  // 434\n\t\tvar users = Meteor.users.find(queryEmails);                                         // 435\n\t\tusers.forEach(function(user) {                                                      // 436\n\t\t\tif (AccountsMeld.getConfig('askBeforeMeld')) {                                     // 437\n\t\t\t\t// Checks if there is already a document about this meld action                   // 438\n\t\t\t\tvar meldAction = MeldActions.findOne({                                            // 439\n\t\t\t\t\tsrc_user_id: user._id,                                                           // 440\n\t\t\t\t\tdst_user_id: dstUser._id                                                         // 441\n\t\t\t\t});                                                                               // 442\n\t\t\t\tif (meldAction) {                                                                 // 443\n\t\t\t\t\t// If the last time the answer was \"Not now\", ask again...                       // 444\n\t\t\t\t\tif (meldAction.meld === \"not_now\") {                                             // 445\n\t\t\t\t\t\tMeldActions.update(meldAction._id, {                                            // 446\n\t\t\t\t\t\t\t$set: {                                                                        // 447\n\t\t\t\t\t\t\t\tmeld: \"ask\"                                                                   // 448\n\t\t\t\t\t\t\t}                                                                              // 449\n\t\t\t\t\t\t});                                                                             // 450\n\t\t\t\t\t}                                                                                // 451\n\t\t\t\t} else {                                                                          // 452\n\t\t\t\t\t// Creates a new meld action                                                     // 453\n\t\t\t\t\tAccountsMeld.createMeldAction(user, dstUser);                                    // 454\n\t\t\t\t}                                                                                 // 455\n\t\t\t} else {                                                                           // 456\n\t\t\t\t// Directly melds the two accounts                                                // 457\n\t\t\t\tAccountsMeld.meldAccounts(user, dstUser);                                         // 458\n\t\t\t}                                                                                  // 459\n\t\t});                                                                                 // 460\n\t}                                                                                    // 461\n};                                                                                    // 462\n                                                                                      // 463\n                                                                                      // 464\nvar createServiceSelector = function(serviceName, serviceData) {                      // 465\n\t// Selector construction copied from                                                 // 466\n\t// accounts-base/accounts_server.js Lines 1114-1131                                  // 467\n\tvar selector = {};                                                                   // 468\n\tvar serviceIdKey = \"services.\" + serviceName + \".id\";                                // 469\n                                                                                      // 470\n\t// XXX Temporary special case for Twitter. (Issue #629)                              // 471\n\t//   The serviceData.id will be a string representation of an integer.               // 472\n\t//   We want it to match either a stored string or int representation.               // 473\n\t//   This is to cater to earlier versions of Meteor storing twitter                  // 474\n\t//   user IDs in number form, and recent versions storing them as strings.           // 475\n\t//   This can be removed once migration technology is in place, and twitter          // 476\n\t//   users stored with integer IDs have been migrated to string IDs.                 // 477\n\tif (serviceName === \"twitter\" && !isNaN(serviceData.id)) {                           // 478\n\t\tselector.$or = [{}, {}];                                                            // 479\n\t\tselector.$or[0][serviceIdKey] = serviceData.id;                                     // 480\n\t\tselector.$or[1][serviceIdKey] = parseInt(serviceData.id, 10);                       // 481\n\t} else {                                                                             // 482\n\t\tselector[serviceIdKey] = serviceData.id;                                            // 483\n\t}                                                                                    // 484\n                                                                                      // 485\n\treturn selector;                                                                     // 486\n};                                                                                    // 487\n                                                                                      // 488\n                                                                                      // 489\nvar origUpdateOrCreateUserFromExternalService =                                       // 490\n\tAccounts.updateOrCreateUserFromExternalService;                                      // 491\n                                                                                      // 492\nupdateOrCreateUserFromExternalService = function(serviceName, serviceData, options) { // 493\n\tvar                                                                                  // 494\n\t\tcurrentUser = Meteor.user(),                                                        // 495\n\t\tselector,                                                                           // 496\n\t\tsetAttr,                                                                            // 497\n\t\tserviceIdKey,                                                                       // 498\n\t\tuser;                                                                               // 499\n                                                                                      // 500\n\tif (currentUser) {                                                                   // 501\n\t\t// The user was already logged in with a different account                          // 502\n\t\t// Checks if the service is already registered with this same account               // 503\n\t\tif (!currentUser.services[serviceName]) {                                           // 504\n\t\t\t// It may be that the same service is already used with a different                // 505\n\t\t\t// account. Checks if there is already an account with this service                // 506\n                                                                                      // 507\n\t\t\t// Creates a selector for the current service                                      // 508\n\t\t\tselector = createServiceSelector(serviceName, serviceData);                        // 509\n\t\t\t// Look for a user with the appropriate service user id.                           // 510\n\t\t\tuser = Meteor.users.findOne(selector);                                             // 511\n\t\t\tif (!user) {                                                                       // 512\n\t\t\t\t// This service is being used for the first time!                                 // 513\n\t\t\t\t// Simply add the service to the current user, and that's it!                     // 514\n\t\t\t\tsetAttr = {};                                                                     // 515\n\t\t\t\tserviceIdKey = \"services.\" + serviceName + \".id\";                                 // 516\n\t\t\t\tsetAttr[serviceIdKey] = serviceData.id;                                           // 517\n\t\t\t\t// This is just to fake updateOrCreateUserFromExternalService so to have          // 518\n\t\t\t\t// it attach the new service to the existing user instead of creating a           // 519\n\t\t\t\t// new one                                                                        // 520\n\t\t\t\tMeteor.users.update({                                                             // 521\n\t\t\t\t\t_id: currentUser._id                                                             // 522\n\t\t\t\t}, {                                                                              // 523\n\t\t\t\t\t$set: setAttr                                                                    // 524\n\t\t\t\t});                                                                               // 525\n\t\t\t\t// Now calls original updateOrCreateUserFromExternalService                       // 526\n\t\t\t\torigUpdateOrCreateUserFromExternalService.apply(this, arguments);                 // 527\n\t\t\t\t// Reloads updated currentUser                                                    // 528\n\t\t\t\tcurrentUser = Meteor.users.findOne(currentUser._id);                              // 529\n\t\t\t\t// Updates the registered_emails field                                            // 530\n\t\t\t\tAccountsEmailsField.updateEmails({                                                // 531\n\t\t\t\t\tuser: currentUser                                                                // 532\n\t\t\t\t});                                                                               // 533\n\t\t\t\t// Checks whether a callback for user update after a new service is               // 534\n\t\t\t\t// added was specified                                                            // 535\n\t\t\t\tvar serviceAddedCbk = AccountsMeld.getConfig('serviceAddedCallback');             // 536\n\t\t\t\tif (serviceAddedCbk) {                                                            // 537\n\t\t\t\t\tserviceAddedCbk(currentUser._id, serviceName);                                   // 538\n\t\t\t\t}                                                                                 // 539\n\t\t\t\t// Cancels the login to save some data exchange with the client                   // 540\n\t\t\t\t// currentUser will remain logged in                                              // 541\n\t\t\t\treturn {                                                                          // 542\n\t\t\t\t\ttype: serviceName,                                                               // 543\n\t\t\t\t\terror: new Meteor.Error(                                                         // 544\n\t\t\t\t\t\tAccounts.LoginCancelledError.numericError,                                      // 545\n\t\t\t\t\t\t\"Service correctly added to the current user, no need to proceed!\"              // 546\n\t\t\t\t\t)                                                                                // 547\n\t\t\t\t};                                                                                // 548\n\t\t\t} else {                                                                           // 549\n\t\t\t\t// This service was already registered for \"user\"                                 // 550\n\t\t\t\tif (AccountsMeld.getConfig('askBeforeMeld')) {                                    // 551\n\t\t\t\t\t// Checks if there is already a document about this meld action                  // 552\n\t\t\t\t\tvar meldAction = MeldActions.findOne({                                           // 553\n\t\t\t\t\t\tsrc_user_id: user._id,                                                          // 554\n\t\t\t\t\t\tdst_user_id: currentUser._id                                                    // 555\n\t\t\t\t\t});                                                                              // 556\n\t\t\t\t\tif (meldAction) {                                                                // 557\n\t\t\t\t\t\t// If the last time the answer was \"Not now\", ask again...                      // 558\n\t\t\t\t\t\tif (meldAction.meld === \"not_now\") {                                            // 559\n\t\t\t\t\t\t\tMeldActions.update(meldAction._id, {                                           // 560\n\t\t\t\t\t\t\t\t$set: {                                                                       // 561\n\t\t\t\t\t\t\t\t\tmeld: \"ask\"                                                                  // 562\n\t\t\t\t\t\t\t\t}                                                                             // 563\n\t\t\t\t\t\t\t});                                                                            // 564\n\t\t\t\t\t\t}                                                                               // 565\n\t\t\t\t\t} else {                                                                         // 566\n\t\t\t\t\t\t// Creates a new meld action                                                    // 567\n\t\t\t\t\t\tAccountsMeld.createMeldAction(user, currentUser);                               // 568\n\t\t\t\t\t}                                                                                // 569\n\t\t\t\t\t// Cancels the login to keep currentUser logged in...                            // 570\n\t\t\t\t\treturn {                                                                         // 571\n\t\t\t\t\t\ttype: serviceName,                                                              // 572\n\t\t\t\t\t\terror: new Meteor.Error(                                                        // 573\n\t\t\t\t\t\t\tAccounts.LoginCancelledError.numericError,                                     // 574\n\t\t\t\t\t\t\t\"Another account registered with the same service was found!\"                  // 575\n\t\t\t\t\t\t)                                                                               // 576\n\t\t\t\t\t};                                                                               // 577\n\t\t\t\t} else {                                                                          // 578\n\t\t\t\t\t// Directly melds the two accounts                                               // 579\n\t\t\t\t\tAccountsMeld.meldAccounts(user, currentUser);                                    // 580\n\t\t\t\t\t// Cancels the login                                                             // 581\n\t\t\t\t\treturn {                                                                         // 582\n\t\t\t\t\t\ttype: serviceName,                                                              // 583\n\t\t\t\t\t\terror: new Meteor.Error(                                                        // 584\n\t\t\t\t\t\t\tAccounts.LoginCancelledError.numericError,                                     // 585\n\t\t\t\t\t\t\t\"Another account registered with the same service was found, \" +               // 586\n\t\t\t\t\t\t\t\"and melded with the current one!\"                                             // 587\n\t\t\t\t\t\t)                                                                               // 588\n\t\t\t\t\t};                                                                               // 589\n\t\t\t\t}                                                                                 // 590\n\t\t\t}                                                                                  // 591\n\t\t}                                                                                   // 592\n\t} else {                                                                             // 593\n\t\t// The user is logging in now...                                                    // 594\n\t\t// Only In case automatic melding is set                                            // 595\n\t\tif (!AccountsMeld.getConfig('askBeforeMeld')) {                                     // 596\n\t\t\t// Creates a selector for the current service                                      // 597\n\t\t\tselector = createServiceSelector(serviceName, serviceData);                        // 598\n\t\t\t// Look for a user with the appropriate service user id.                           // 599\n\t\t\tuser = Meteor.users.findOne(selector);                                             // 600\n\t\t\tif (!user) {                                                                       // 601\n\t\t\t\t// This service is being used for the first time!                                 // 602\n\t\t\t\t// Extracts the email address associated with the current service                 // 603\n\t\t\t\tvar serviceEmails = AccountsEmailsField.getEmailsFromService(                     // 604\n\t\t\t\t\tserviceName, serviceData                                                         // 605\n\t\t\t\t).filter(function(serviceEmail) {                                                 // 606\n\t\t\t\t\treturn serviceEmail.verified;                                                    // 607\n\t\t\t\t});                                                                               // 608\n\t\t\t\t// In case it is a verified email...                                              // 609\n\t\t\t\tif (serviceEmails.length) {                                                       // 610\n\t\t\t\t\t// ...checks whether the email address used with the service is                  // 611\n\t\t\t\t\t// already associated with an existing account.                                  // 612\n\t\t\t\t\tselector = {                                                                     // 613\n\t\t\t\t\t\t$or: serviceEmails.map(function(serviceEmail) {                                 // 614\n\t\t\t\t\t\t\treturn {                                                                       // 615\n\t\t\t\t\t\t\t\t\"registered_emails\": {$elemMatch: serviceEmail}                               // 616\n\t\t\t\t\t\t\t};                                                                             // 617\n\t\t\t\t\t\t})                                                                              // 618\n\t\t\t\t\t};                                                                               // 619\n\t\t\t\t\tvar otherUser = Meteor.users.findOne(selector);                                  // 620\n\t\t\t\t\tif (otherUser) {                                                                 // 621\n\t\t\t\t\t\t// Simply add the service to 'user', and that's it!                             // 622\n\t\t\t\t\t\tsetAttr = {};                                                                   // 623\n\t\t\t\t\t\tserviceIdKey = \"services.\" + serviceName + \".id\";                               // 624\n\t\t\t\t\t\tsetAttr[serviceIdKey] = serviceData.id;                                         // 625\n\t\t\t\t\t\t// This is just to fake updateOrCreateUserFromExternalService so to             // 626\n\t\t\t\t\t\t// have it attach the new service to the existing user instead of               // 627\n\t\t\t\t\t\t// creating a new one                                                           // 628\n\t\t\t\t\t\tMeteor.users.update({                                                           // 629\n\t\t\t\t\t\t\t_id: otherUser._id                                                             // 630\n\t\t\t\t\t\t}, {                                                                            // 631\n\t\t\t\t\t\t\t$set: setAttr                                                                  // 632\n\t\t\t\t\t\t});                                                                             // 633\n\t\t\t\t\t}                                                                                // 634\n\t\t\t\t}                                                                                 // 635\n\t\t\t}                                                                                  // 636\n\t\t}                                                                                   // 637\n\t}                                                                                    // 638\n\t// Let the user in!                                                                  // 639\n\treturn origUpdateOrCreateUserFromExternalService.apply(this, arguments);             // 640\n};                                                                                    // 641\n                                                                                      // 642\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/splendido:accounts-meld/lib/accounts-meld-hooks.js                        //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n/* global                                                                             // 1\n\tcheckForMelds: false,                                                                // 2\n\tupdateOrCreateUserFromExternalService: false                                         // 3\n*/                                                                                    // 4\n'use strict';                                                                         // 5\n                                                                                      // 6\n// Register `updateOrCreateUserFromExternalService` function to                       // 7\n// be used in place of the original                                                   // 8\n// `Accounts.updateOrCreateUserFromExternalService`                                   // 9\nAccounts.updateOrCreateUserFromExternalService =                                      // 10\n\tupdateOrCreateUserFromExternalService;                                               // 11\n                                                                                      // 12\n                                                                                      // 13\n// Register `updateEmails` and checkPasswordLogin` functions                          // 14\n// to be triggered with the `onLogin` hook                                            // 15\nAccounts.onLogin(function(attempt) {                                                  // 16\n                                                                                      // 17\n\t// Reload user object which was possibly modified                                    // 18\n\t// by splendido:accounts-emails-field by a previous onLogin callback                 // 19\n\t// note: the *attempt* object is cloned for each hook callback                       // 20\n\t//       se there's no way to get the modified user object from the                  // 21\n\t//       *attempt* one...                                                            // 22\n\tvar user = Meteor.users.findOne(attempt.user._id);                                   // 23\n                                                                                      // 24\n\t// Checks for possible meld actions to be created                                    // 25\n\tcheckForMelds(user);                                                                 // 26\n});                                                                                   // 27\n                                                                                      // 28\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}