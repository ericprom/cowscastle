{"version":3,"sources":["meteor://ðŸ’»app/packages/brishin_meteor-elasticsearch/packages/brishin_meteor-elasticsearch.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H","file":"/packages/brishin_meteor-elasticsearch.js","sourcesContent":["(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/brishin:meteor-elasticsearch/elasticsearch.coffee.js                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Fiber, elasticsearch, queryDSL;    \n\nFiber = Npm.require('fibers');\n\nelasticsearch = Npm.require('elasticsearch');\n\nqueryDSL = Npm.require('elastic.js');\n\nES = new elasticsearch.Client(Meteor.settings.elasticsearch);\n\nif (Meteor.settings && Meteor.settings.elasticsearch && Meteor.settings.elasticsearch.meteorLogger === \"enabled\") {\n  Logger.enableLog(\"elasticsearch\");\n}\n\nES.queryDSL = queryDSL;\n\nES.river = {\n\n  /*\n    Create River\n    @collection - name of the collection to river\n    @options - optional object - all the same ones from the mongodb river docs .. and added:\n      @mapping: optionally specify a mapping configuration\n      @index: optionally specify an index name\n   */\n  create: function(collection, options, callback) {\n    var credentials, filter, gridfs, index, mongodbOptions, putRiver, servers;\n    index = options && options.index || Meteor.settings.app_name.replace(/\\s+/g, '-').toLowerCase() || \"meteor-river\";\n    mongodbOptions = options && options.options;\n    servers = null;\n    credentials = null;\n    gridfs = null;\n    filter = null;\n    putRiver = function(cb) {\n      var db, settings;\n      db = process.env.MONGO_URL.split('/');\n      db = db[db.length - 1];\n      if (db.indexOf('?') !== -1) {\n        db = db.substring(0, db.indexOf('?'));\n      }\n      settings = {\n        type: \"mongodb\",\n        mongodb: {\n          db: db,\n          collection: collection,\n          options: mongodbOptions\n        },\n        index: {\n          name: index,\n          type: collection\n        }\n      };\n      if (servers) {\n        settings.mongodb.servers = servers;\n      }\n      if (credentials) {\n        settings.mongodb.credentials = credentials;\n      }\n      if (gridfs) {\n        settings.mongodb.gridfs = gridfs;\n      }\n      if (filter) {\n        settings.mongodb.filter = filter;\n      }\n      return HTTP.put(\"http://\" + Meteor.settings.elasticsearch.host + \"/_river/\" + collection + \"/_meta\", {\n        data: settings\n      }, function(err, res) {\n        if (err) {\n          return Logger.log(\"elasticsearch\", \"Error creating river for \" + collection + \" collection.\");\n        } else {\n          Logger.log(\"elasticsearch\", \"Created river for \" + collection + \" collection.\");\n          return cb(res.content);\n        }\n      });\n    };\n    if (options) {\n      if (options.index) {\n        delete options.index;\n      }\n      if (options.gridfs) {\n        gridfs = options.gridfs;\n        delete options.gridfs;\n      }\n      if (options.credentials) {\n        credentials = options.credentials;\n        delete options.credentials;\n      }\n      if (options.filter) {\n        filter = options.filter;\n        delete options.filter;\n      }\n      if (options.servers) {\n        servers = options.servers;\n        delete options.servers;\n      }\n      if (options.mapping) {\n        return ES.indices.putMapping({\n          index: index,\n          type: collection,\n          body: options.mapping\n        }, Meteor.bindEnvironment(function(err, result) {\n          Logger.log(\"elasticsearch\", \"Put \" + collection + \" mapping.\");\n          delete options.mapping;\n          return putRiver(function(res) {\n            if (callback) {\n              return callback(null, res);\n            }\n          });\n        }), function(err) {\n          return console.log(err);\n        });\n      } else {\n        return putRiver(function(res) {\n          if (callback) {\n            return callback(null, res);\n          }\n        });\n      }\n    } else {\n      return putRiver(function(res) {\n        if (callback) {\n          return callback(null, res);\n        }\n      });\n    }\n  },\n\n  /*\n    Destroy River\n    @collection - name of the collection of the river to destroy\n   */\n  destroy: function(collection, callback) {\n    return HTTP.del(\"http://\" + Meteor.settings.elasticsearch.host + \"/_river/\" + collection, function(err, res) {\n      Logger.log(\"elasticsearch\", \"Destroyed river for \" + collection + \" collection.\");\n      if (callback) {\n        return callback(err, res);\n      }\n    });\n  },\n\n  /*\n    Delete Type\n    @collection - name of the collection of the river to destroy\n   */\n  \"delete\": function(index, collection, callback) {\n    return HTTP.del(\"http://\" + Meteor.settings.elasticsearch.host + \"/\" + index + \"/\" + collection, function(err, res) {\n      Logger.log(\"elasticsearch\", \"Deleted river data for \" + collection + \" collection.\");\n      if (callback) {\n        return callback(err, res);\n      }\n    });\n  },\n\n  /*\n    Reriver\n    @collection - name of the collection to river\n    @options - optional object\n      @fields = array of fields to river into ES\n   */\n  reriver: function(collection, options, callback) {\n    var index;\n    index = options && options.index || Meteor.settings.app_name.replace(/\\s+/g, '-').toLowerCase() || \"meteor-river\";\n    return this.destroy(collection, (function(_this) {\n      return function(err, res) {\n        return _this[\"delete\"](index, collection, function(err, res) {\n          return _this.create(collection, options, function(err, res) {\n            if (callback) {\n              return callback(err, res);\n            }\n          });\n        });\n      };\n    })(this));\n  }\n};\n\nthis.ES = ES;\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/brishin:meteor-elasticsearch/methods.coffee.js                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Future;\n\nFuture = Npm.require('fibers/future');\n\nMeteor.methods({\n\n  /*\n    Search\n    @query: string value to search for\n    @options: optional object with optional params\n      @collection: name of the collection to search\n      @fileds: array of field names to search\n      @size: number of results to return\n   */\n  search: function(searchQuery, options) {\n    var f, field, future, index, query, _i, _len, _ref;\n    index = options && options.index || Meteor.settings.app_name.replace(/\\s+/g, '-').toLowerCase() || \"meteor-river\";\n    query = {\n      index: index,\n      body: {\n        query: {\n          match: {\n            name: searchQuery\n          }\n        }\n      }\n    };\n    if (options) {\n      if (options.collection) {\n        query.type = options.collection;\n      }\n      if (options.fields) {\n        query.body.query = {\n          bool: {\n            should: []\n          }\n        };\n        _ref = options.fields;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          field = _ref[_i];\n          f = {\n            match: {}\n          };\n          f.match[field] = searchQuery;\n          query.body.query.bool.should.push(f);\n        }\n      }\n      if (options.size) {\n        query.body.size = options.size;\n      }\n    }\n    future = new Future();\n    ES.search(query).then(function(resp) {\n      var hits;\n      hits = resp.hits.hits;\n      Logger.log(\"elasticsearch\", 'Search results for \"' + searchQuery + '\" returned', resp);\n      return future[\"return\"](hits);\n    }, function(err) {\n      return console.trace(err.message);\n    });\n    return future.wait();\n  }\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}